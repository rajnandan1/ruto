!(function (e, t) {
    'object' == typeof exports && 'undefined' != typeof module ? t(exports) : 'function' == typeof define && define.amd ? define(['exports'], t) : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).ruto = {}));
})(this, function (e) {
    'use strict';
    function t(e) {
        if (e.startsWith('*')) return '*';
        if (e.startsWith('/')) return '';
        const t = document.createElement('a');
        return (t.href = e), t.origin;
    }
    function i(e) {
        const i = t(e),
            n = e.replace(i, '').split('/')[1];
        return n.startsWith('parent') ? 'parent' : n.startsWith('iframe') ? 'iframe' : n.startsWith('window') ? 'window' : 'parent';
    }
    function n(e) {
        const i = t(e),
            n = e.replace(i, '').split('/')[1];
        return n.endsWith('parent') ? 'parent' : n.endsWith('iframe') ? 'iframe' : n.endsWith('window') ? 'window' : 'iframe';
    }
    function o(e) {
        const i = t(e),
            n = e.replace(i, '');
        if (!n.startsWith('/')) return !1;
        const o = n.split('/');
        if (3 != o.length) return !1;
        const s = o[1];
        return !!(s.startsWith('parent') || s.startsWith('iframe') || s.startsWith('window')) && !(s.startsWith('parent') && !s.endsWith('iframe') && !s.endsWith('window')) && !((s.startsWith('iframe') || s.startsWith('window')) && !s.endsWith('parent'));
    }
    class s {
        constructor(e, o, s) {
            this.send = (e) =>
                new Promise((t, i) => {
                    var n;
                    if (((this.resolver = t), (this.rejecter = i), null == this.client.node || null == this.client.node)) return i('Client Unhealthy');
                    if ('undefined' == typeof window || 'undefined' == typeof document) return t('');
                    try {
                        const t = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (e) {
                                const t = (16 * Math.random()) | 0;
                                return ('x' == e ? t : (3 & t) | 8).toString(16);
                            }),
                            i = { message: e, subpath: this.client.subpath, id: t, fromOrigin: this.client.fromOrigin, toOrigin: this.client.toOrigin, nodeTypeTo: this.client.nodeTypeTo, nodeTypeFrom: this.client.nodeTypeFrom };
                        if ('iframe' == this.client.nodeTypeTo) {
                            const e = this.client.node;
                            this.client.nodeReady
                                ? null === (n = e.contentWindow) || void 0 === n || n.postMessage(i, this.client.toOrigin)
                                : (function (e, t) {
                                      return new Promise((i, n) => {
                                          const o = setTimeout(() => {
                                                  clearInterval(s), n(new Error('Timeout exceeded'));
                                              }, t),
                                              s = setInterval(() => {
                                                  e.contentWindow && (clearInterval(s), clearTimeout(o), i());
                                              }, 100);
                                      });
                                  })(e, this.timeout).then(() => {
                                      var t;
                                      (this.client.nodeReady = !0), null === (t = e.contentWindow) || void 0 === t || t.postMessage(i, this.client.toOrigin);
                                  });
                        } else if ('parent' == this.client.nodeTypeTo) {
                            this.client.node.postMessage(i, this.client.toOrigin);
                        } else if ('window' == this.client.nodeTypeTo) {
                            this.client.node.postMessage(i, this.client.toOrigin);
                        }
                        const o = setTimeout(() => {
                                this.rejecter('Timeout'), window.removeEventListener('message', s);
                            }, this.timeout),
                            s = (e) => {
                                var i;
                                ('*' != e.data.fromOrigin && e.origin !== e.data.fromOrigin) || ((null === (i = e.data) || void 0 === i ? void 0 : i.subpath) === this.client.subpath && e.data.id === t && (this.resolver(e.data.message), window.removeEventListener('message', s), clearTimeout(o)));
                            };
                        window.addEventListener('message', s);
                    } catch (e) {
                        this.rejecter(e);
                    }
                });
            const r = t(e);
            (this.client = { node: o, nodeTypeTo: n(e), nodeTypeFrom: i(e), toOrigin: r, fromOrigin: t(window.location.href), subpath: e.replace(r, ''), nodeReady: !1 }), (this.timeout = (null == s ? void 0 : s.timeout) || 3e3), (this.resolver = (e) => {}), (this.rejecter = (e) => {});
        }
    }
    class r {
        constructor(e, t) {
            (this.send = (e) => {
                var t;
                const i = { id: this.messageId, message: e, fromOrigin: this.client.fromOrigin, toOrigin: this.client.toOrigin, nodeTypeTo: this.client.nodeTypeTo, nodeTypeFrom: this.client.nodeTypeFrom, subpath: this.client.subpath };
                let n = this.client.nodeTypeFrom,
                    o = this.client.nodeTypeTo;
                if ('iframe' == n && 'parent' == o) {
                    this.client.node.postMessage(i, this.client.toOrigin);
                } else if ('parent' == n && 'iframe' == o) {
                    null === (t = this.client.node.contentWindow) || void 0 === t || t.postMessage(i, this.client.toOrigin);
                } else if ('window' == n && 'parent' == o) {
                    this.client.node.postMessage(i, this.client.toOrigin);
                } else if ('parent' == n && 'window' == o) {
                    this.client.node.postMessage(i, this.client.toOrigin);
                }
            }),
                (this.messageId = e),
                (this.client = t);
        }
    }
    class a {
        constructor() {
            this.receive = (e, t, i) => {
                'undefined' != typeof window &&
                    'undefined' != typeof document &&
                    window.addEventListener('message', (n) => {
                        var o;
                        if (n.origin !== n.data.fromOrigin) return;
                        if ((null === (o = n.data) || void 0 === o ? void 0 : o.subpath) !== e) return;
                        if ('parent' == n.data.nodeTypeFrom && 'window' == n.data.nodeTypeTo && n.source != t) return;
                        const s = { node: t, nodeTypeTo: n.data.nodeTypeFrom, nodeTypeFrom: n.data.nodeTypeTo, toOrigin: n.data.fromOrigin, fromOrigin: n.data.toOrigin, subpath: e, nodeReady: !1 },
                            a = new r(n.data.id, s);
                        i(a, n.data.message);
                    });
            };
        }
    }
    (e.receive = function (e, t, i) {
        if (!o(e)) throw new Error('Invalid Path');
        new a().receive(e, t, i);
    }),
        (e.send = function (e, t, i, n) {
            if (!o(e)) throw new Error('Invalid Path');
            return new s(e, t, n).send(i);
        });
});
//# sourceMappingURL=ruto.min.js.map
